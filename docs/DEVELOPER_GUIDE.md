# Руководство разработчика Nota AI Bot

Это руководство предназначено для разработчиков, работающих над проектом Nota AI Bot. Здесь вы найдете информацию о настройке окружения, архитектуре проекта, ключевых компонентах, стандартах кодирования, тестировании и расширении функциональности.

## Содержание

- [1. Обзор проекта](#1-обзор-проекта)
- [2. Установка и настройка](#2-установка-и-настройка)
  - [Требования](#требования)
  - [Шаги по установке](#шаги-по-установке)
  - [Переменные окружения](#переменные-окружения)
- [3. Архитектура проекта](#3-архитектура-проекта)
  - [Общая структура](#общая-структура)
  - [Ключевые компоненты](#ключевые-компоненты)
  - [Основные модули и их функции](#основные-модули-и-их-функции)
- [4. Ключевые классы и функции](#4-ключевые-классы-и-функции)
- [5. Система парсеров команд](#5-система-парсеров-команд)
  - [Обзор системы парсеров](#обзор-системы-парсеров)
  - [Использование и примеры](#использование-и-примеры)
- [6. Стандарты кодирования](#6-стандарты-кодирования)
- [7. Тестирование](#7-тестирование)
  - [Структура тестов](#структура-тестов)
  - [Запуск тестов](#запуск-тестов)
  - [Особенности тестирования OCR](#особенности-тестирования-ocr)
  - [Принципы написания тестов](#принципы-написания-тестов)
  - [Фикстуры и маркеры](#фикстуры-и-маркеры)
  - [План тестирования компонентов](#план-тестирования-компонентов)
- [8. Отладка](#8-отладка)
  - [Остановка фоновых процессов](#остановка-фоновых-процессов)
  - [Запуск в режиме отладки](#запуск-в-режиме-отладки)
  - [Анализ логов](#анализ-логов)
- [9. Расширение функциональности](#9-расширение-функциональности)
  - [Добавление нового обработчика](#добавление-нового-обработчика)
  - [Добавление нового языка](#добавление-нового-языка)
  - [Интеграция с новой системой](#интеграция-с-новой-системой)
- [10. Советы по разработке](#10-советы-по-разработке)

## 1. Обзор проекта

Nota AI - это автоматизированный бот для Telegram, предназначенный для быстрого и точного преобразования бумажных инвойсов поставщиков в цифровой формат. Проект решает проблему ручного ввода данных, снижая количество ошибок и экономя время персонала.

Основные возможности включают распознавание инвойсов (OCR), предобработку изображений, сопоставление позиций с каталогом, интерактивное редактирование, интеграцию с Syrve и многоязычный интерфейс.

(Более подробное описание можно найти в старом `docs/PROJECT_OVERVIEW.md` или интегрировать сюда по необходимости)

## 2. Установка и настройка

### Требования

- Python 3.10 или выше
- Redis (рекомендуется)
- pip и virtualenv/venv

### Шаги по установке

1.  Клонируйте репозиторий:
    ```bash
    git clone <URL_РЕПОЗИТОРИЯ>
    cd Nota-v3-
    ```
2.  Создайте и активируйте виртуальное окружение:
    ```bash
    python -m venv venv
    source venv/bin/activate  # для Linux/macOS
    # или .venv\Scripts\activate  # для Windows
    ```
3.  Установите зависимости:
    ```bash
    pip install -r requirements.txt
    ```
4.  Настройте переменные окружения:
    Скопируйте `.env.example` или `.env.minimal` в `.env` и заполните необходимые значения.
    ```bash
    cp .env.example .env
    # Отредактируйте .env файл
    ```

### Переменные окружения

Основные переменные (детали см. в `.env.example` и `app/config/settings.py`):
-   `TELEGRAM_TOKEN`: Токен вашего Telegram бота.
-   `OPENAI_OCR_KEY`, `OPENAI_CHAT_KEY`: Ключи API OpenAI.
-   `OPENAI_ASSISTANT_ID`: ID ассистента OpenAI (если используется).
-   `SYRVE_API_URL`, `SYRVE_LOGIN`, `SYRVE_PASSWORD`, etc.: Данные для интеграции с Syrve.
-   `REDIS_URL`: URL для подключения к Redis.
-   `ADMIN_CHAT_ID`: ID чата администратора для уведомлений.
-   `MATCH_THRESHOLD`: Порог для fuzzy-сопоставления товаров.

## 3. Архитектура проекта

### Общая структура

(Взято из `docs/PROJECT_OVERVIEW.md`)
```
Nota-v3-/
├── app/                   # Основной код приложения
│   ├── i18n/              # Система локализации
│   ├── assistants/        # Интеграция с OpenAI Assistant API
│   ├── core/              # Базовая функциональность (OCR, parser)
│   ├── edit/              # Логика редактирования
│   ├── formatters/        # Форматирование отчетов и данных
│   ├── fsm/               # Конечные автоматы состояний
│   ├── handlers/          # Обработчики сообщений Telegram
│   ├── imgprep/           # Предобработка изображений
│   └── utils/             # Вспомогательные инструменты
├── data/                  # Каталоги продуктов, алиасы и т.д.
├── docs/                  # Документация
├── infra/                 # Инфраструктурные компоненты (мониторинг)
├── prompts/               # Промпты для GPT моделей
├── scripts/               # Вспомогательные скрипты
├── tests/                 # Тесты
└── tools/                 # Утилиты для управления проектом
```

### Ключевые компоненты

(Взято из `docs/PROJECT_OVERVIEW.md`)
1.  **Telegram Bot**: Интерфейс взаимодействия с пользователем.
2.  **FSM (Finite State Machine)**: Управление состояниями диалога.
3.  **OCR Engine**: Распознавание текста на изображениях (GPT-4o).
4.  **Matcher**: Система сопоставления позиций с каталогом.
5.  **Edit Handler**: Обработка команд редактирования.
6.  **Syrve Client**: Интеграция с POS системой.
7.  **Parsers**: Модули для разбора команд пользователя (см. раздел [Система парсеров команд](#5-система-парсеров-команд)).

### Основные модули и их функции

(Взято из `docs/PROJECT_OVERVIEW.md` и `docs/developer_guide/README.md`, дополнено)

-   `app/config/settings.py`: Основные настройки приложения.
-   `app/data_loader.py`: Загрузка CSV файлов (продукты, поставщики, алиасы).
-   `app/assistants/`: Взаимодействие с OpenAI Assistant API.
    -   `client.py`: Клиент для OpenAI API.
    -   `intent_adapter.py`: Преобразование ответов Assistant API.
-   `app/core/`:
    -   `ocr.py`: Функции для работы с OCR (OpenAI Vision).
    -   `parser.py`: (уточнить назначение, возможно, часть старой системы)
-   `app/edit/`: Логика редактирования инвойсов.
    -   `apply_intent.py`: Применение интентов от GPT к данным инвойса.
    -   `free_parser.py`: Парсер свободных команд редактирования (может быть устаревшим, см. `app/parsers`).
-   `app/fsm/states.py`: Определения состояний FSM для бота.
-   `app/handlers/`: Обработчики сообщений и коллбэков.
    -   `edit_flow.py`: Логика потока редактирования.
-   `app/imgprep/prepare.py`: Функции предобработки изображений.
-   `app/matcher.py`: Логика точного и нечеткого сопоставления товаров.
-   `app/parsers/`: Модульная система парсинга команд пользователя (см. раздел [Система парсеров команд](#5-система-парсеров-команд)).
-   `app/postprocessing.py`: Постобработка результатов OCR (автокоррекция чисел, названий).
-   `app/utils/`: Вспомогательные утилиты (декораторы API, кэширование, логгеры).
-   `bot.py`: Точка входа в приложение, инициализация и запуск бота.

## 4. Ключевые классы и функции

(Взято из `docs/PROJECT_OVERVIEW.md`)
-   **SyrveClient**: Клиент для взаимодействия с Syrve API.
-   **IncrementalUI**: Класс для пошаговых обновлений UI.
-   **EditCommand**: Модель команды редактирования.
-   **ParsedData**: Модель данных распознанного инвойса.
-   **`prepare_for_ocr()`**: Предобработка изображения для OCR.
-   **`call_openai_ocr()`**: Распознавание текста с помощью OpenAI API.
-   **`match_positions()`**: Сопоставление позиций с каталогом.
-   **`fuzzy_find()`**: Нечеткий поиск товаров по названию.
-   **`apply_intent()`**: Применение команды редактирования.
-   **`t()`**: Функция для локализации строк.
-   **`postprocess_parsed_data()`**: Постобработка данных после OCR.

## 5. Система парсеров команд

(Основано на `docs/PARSERS.md`)

### Обзор системы парсеров
Система парсеров команд (`app/parsers/`) предназначена для распознавания различных команд пользователя в процессе редактирования инвойсов. Она модульная, расширяемая и обеспечивает логирование.

Ключевые модули:
-   `text_processor.py`: Базовые утилиты обработки текста.
-   `line_parser.py`: Парсер команд редактирования строк.
-   `date_parser.py`: Парсер команд редактирования даты.
-   `command_parser.py`: Интегрированный парсер (основная точка входа).
-   `errors.py`: Управление сообщениями об ошибках парсинга.

### Использование и примеры
Основная точка входа - `parse_command` и `parse_compound_command` в `app/parsers/command_parser.py`.
```python
from app.parsers.command_parser import parse_command
result = parse_command("строка 1 цена 500", invoice_lines=3)

from app.parsers.command_parser import parse_compound_command
results = parse_compound_command("строка 1 цена 500; дата 01.02.2023", invoice_lines=3)
```
Поддерживаются команды для редактирования строк (цена, название, количество, единица), даты, поставщика, а также удаление и добавление строк. Система также предоставляет локализованные сообщения об ошибках.

Для миграции со старой системы `free_parser.py` можно использовать адаптер `app/assistants/parser_adapter.py` (`parse_edit_command_enhanced`).

### Поддержка множественных команд редактирования (Multi-Edit)

Система парсинга поддерживает ввод нескольких команд редактирования в одном сообщении от пользователя. Команды могут быть разделены запятыми, точками с запятой или точками.

**Принцип работы:**
1.  Пользовательский ввод разделяется по знакам препинания (запятая, точка с запятой, точка) на отдельные команды. Используется регулярное выражение, которое избегает разделения чисел с десятичной точкой (например, `3.14`).
2.  Промпт для OpenAI Assistant обновлен для обработки нескольких команд и возврата их в виде массива `actions`.

**Детали реализации:**
Логика разделения команд находится в `app/assistants/client.py` (или аналогичном месте, отвечающем за первичную обработку ввода для ассистента):
```python
# Примерный код разделения команд
import re
# Сначала новые строки заменяются на точки с запятой
cleaned_input = user_input.replace('
', ';')
# Разделение по точкам с запятой, запятым или точкам, за которыми следует пробел или конец строки
commands = [c.strip() for c in re.split(r'[;,.](?=\s|\Z)', cleaned_input) if c.strip()]
```

Для обновления системного промпта ассистента может использоваться скрипт `scripts/update_assistant.py`.

**Примеры использования:**
Пользователи могут вводить команды типа:
- "строка 1 цена 100, строка 2 количество 5"
- "дата 01.06.2025. Добавить молоко 2 л 120 руб. изменить цену в строке 3 на 200."

Тесты для этой функциональности находятся в `tests/test_parse_commands_edge_cases.py` (или аналогичном файле).

## 6. Стандарты кодирования

-   Следуйте **PEP 8**.
-   Максимальная длина строки: 100 символов.
-   Используйте `snake_case` для переменных и функций.
-   Активно используйте **типизацию** в новом коде.
-   Документируйте все публичные функции, классы и сложные участки кода (docstrings, комментарии).
-   Все текстовые строки, видимые пользователю, должны проходить через систему локализации (`t()` из `app/i18n`).

## 7. Тестирование

(Основано на `docs/TESTING.md` и `docs/technical/TEST_PLAN.md`)

### Структура тестов
-   `tests/` (ранее `tests/unit/`): Юнит-тесты.
-   `tests/integration/`: Интеграционные тесты.
-   `tests/e2e/`: End-to-end тесты.

### Запуск тестов
```bash
# Запуск всех тестов
pytest
PYTHONPATH=. pytest # если есть проблемы с импортами

# Запуск тестов для конкретного модуля
pytest tests/parsers/test_date_parser.py

# Запуск с отчетом о покрытии
pytest --cov=app --cov-report=html
```
Для упрощения можно использовать скрипт типа `./tests/unit/run_tests.sh` (если он актуален).

### Особенности тестирования OCR
-   **Stub mode** (по умолчанию): Без реальных запросов к OpenAI, использует моки, быстрые тесты.
-   **Live mode**: Установите `USE_OPENAI_OCR=1` и `OPENAI_API_KEY` для тестов с реальным API GPT-4o Vision.

### Принципы написания тестов
-   **Изоляция**: Тесты должны быть независимы.
-   **Моки**: Используйте моки (`unittest.mock`) для внешних зависимостей.
-   **Граничные случаи**: Тестируйте поведение на граничных значениях и при ошибках.
-   **Читаемость**: Тесты должны быть понятными.

### Фикстуры и маркеры
Используются стандартные фикстуры pytest (см. `tests/conftest.py`) и маркеры (`@pytest.mark.unit`, `@pytest.mark.integration`, и т.д.).

### План тестирования компонентов
(См. `docs/technical/TEST_PLAN.md` для примеров тест-кейсов)
-   Редактирование цены, даты.
-   Тесты компонентов `apply_intent`.
-   Автокоррекция числовых значений и названий.
-   Асинхронная обработка фото и команд.

## 8. Отладка

(Основано на `DEBUG_INSTRUCTIONS.md`)

### Остановка фоновых процессов
Если бот запущен в фоновом режиме (systemd, `run_forever.sh`), остановите его с помощью `stop_background_bot.sh` или вручную.

### Запуск в режиме отладки
Используйте `debug_bot.sh` (или `run_debug.sh`) для запуска с подробным логированием в консоль.
Скрипт обычно активирует venv и устанавливает нужные переменные окружения.

### Анализ логов
Используйте `debug_logs.sh` (если актуален) или просматривайте файлы в `logs/`.
Логи в режиме отладки могут иметь префикс `debug_`.

## 9. Расширение функциональности

(Взято из `docs/PROJECT_OVERVIEW.md`)

### Добавление нового обработчика
1.  Создайте новый файл в `app/handlers/`.
2.  Определите `Router`: `router = Router()`.
3.  Добавьте обработчики (`@router.message()`, `@router.callback_query()`).
4.  Зарегистрируйте роутер в `bot.py` или `app/register_handlers.py`: `dp.include_router(your_router)`.

### Добавление нового языка
1.  Создайте файл `app/i18n/texts_XX.yaml` (где `XX` - код языка).
2.  Скопируйте структуру из `texts_en.yaml` и переведите строки.
3.  Обновите логику выбора языка в UI, если это необходимо.

### Интеграция с новой системой
1.  Создайте клиент API (аналогично `syrve_client.py`).
2.  Реализуйте методы для взаимодействия.
3.  Добавьте новый обработчик для управления интеграцией.

## 10. Советы по разработке

(Взято из `docs/PROJECT_OVERVIEW.md`)
1.  **Локализация**: Всегда используйте функцию `t()` для текстовых строк интерфейса.
2.  **Обработка ошибок**: Используйте декораторы из `app/utils/api_decorators.py` для API-запросов.
3.  **Логирование**: Используйте стандартный модуль `logging` с правильными уровнями.
4.  **Кэширование**: Используйте функции `cache_set` и `cache_get` (например, из `app/utils/redis_cache.py`) для кэширования данных.
5.  **Метрики**: Используйте функции для записи метрик (например, `increment_counter`, `record_histogram` из `app/utils/monitor.py`), если система мониторинга настроена.
6.  **Асинхронность**: Все I/O операции (API запросы, работа с файлами) должны быть асинхронными (`async/await`), либо выполняться в отдельных потоках (`to_thread`) для неблокирующих операций.
```
