import asyncio
import concurrent.futures
import logging
import re
import os
from app.formatters.report import build_report
import atexit
import uuid
import json
import time
import shutil
from typing import Dict, Any
from pathlib import Path
import signal
import sys
from json_trace_logger import setup_json_trace_logger
from app.handlers.tracing_log_middleware import TracingLogMiddleware
import argparse
from app.utils.file_manager import cleanup_temp_files, ensure_temp_dirs

# Aiogram –∏–º–ø–æ—Ä—Ç—ã
from aiogram import Bot, Dispatcher, F
from aiogram.fsm.context import FSMContext
from aiogram.filters import Command, CommandStart
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.exceptions import TelegramBadRequest
from aiogram.enums import ParseMode
from aiogram.types import CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏—è
from app.fsm.states import EditFree, NotaStates

# –ò–º–ø–æ—Ä—Ç—ã –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
from app import ocr, matcher, data_loader
from app.utils.md import escape_html, clean_html
from app.config import settings
from app.i18n import t

# –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
from app.handlers.edit_flow import router as edit_flow_router

# Import optimized logging configuration
from app.utils.logger_config import configure_logging, get_buffered_logger

# Configure logging with optimized settings
configure_logging(environment=os.getenv("ENV", "development"), log_dir="logs")

# Get buffered logger for this module
logger = get_buffered_logger(__name__)

# Create tmp dir if not exists
TMP_DIR = Path("tmp")
TMP_DIR.mkdir(exist_ok=True)

# –°–æ–∑–¥–∞–µ–º –≤—Å–µ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ
ensure_temp_dirs()

async def periodic_cleanup():
    """–ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏ –æ—á–∏—â–∞–µ—Ç —Å—Ç–∞—Ä—ã–µ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã."""
    while True:
        try:
            cleanup_count = await asyncio.to_thread(cleanup_temp_files)
            if cleanup_count > 0:
                print(f"Periodic cleanup: removed {cleanup_count} old temp files")
        except Exception as e:
            print(f"Error during periodic cleanup: {e}")
        await asyncio.sleep(3600)  # 1 —á–∞—Å

def cleanup_tmp():
    try:
        shutil.rmtree(TMP_DIR)
        TMP_DIR.mkdir(exist_ok=True)
        logger.info("Cleaned up tmp directory.")
    except Exception as e:
        logger.error(f"Failed to clean tmp/: {e}")


atexit.register(cleanup_tmp)


def create_bot_and_dispatcher():
    setup_json_trace_logger()
    storage = MemoryStorage()
    # –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å aiogram 3.7.0+
    from aiogram.client.default import DefaultBotProperties
    bot = Bot(token=settings.TELEGRAM_BOT_TOKEN, default=DefaultBotProperties(parse_mode="HTML"))
    dp = Dispatcher(storage=storage)
    dp.message.middleware(TracingLogMiddleware())
    dp.callback_query.middleware(TracingLogMiddleware())
    # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —Ä–æ—É—Ç–µ—Ä–æ–≤ —Ç–µ–ø–µ—Ä—å —Ç–æ–ª—å–∫–æ –≤ register_handlers
    return bot, dp


# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ bot –∏ dp —É–±—Ä–∞–Ω—ã –¥–ª—è —Ç–µ—Å—Ç–∏—Ä—É–µ–º–æ—Å—Ç–∏.
bot = None
dp = None
# –ì–ª–æ–±–∞–ª—å–Ω—ã–π –∫—ç—à –¥–ª—è –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
_edit_cache: Dict[str, Dict[str, Any]] = {}
# assistant_thread_id —É–±—Ä–∞–Ω –∏–∑ –≥–ª–æ–±–∞–ª—å–Ω—ã—Ö –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏ –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω –≤ FSMContext


user_matches = {}


def is_inline_kb(kb):
    return kb is None or isinstance(kb, InlineKeyboardMarkup)


# Import the optimized version of safe_edit
from app.utils.optimized_safe_edit import optimized_safe_edit

async def safe_edit(bot, chat_id, msg_id, text, kb=None, **kwargs):
    """
    –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º –∏ –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫.
    
    Args:
        bot: –≠–∫–∑–µ–º–ø–ª—è—Ä –±–æ—Ç–∞
        chat_id: ID —á–∞—Ç–∞
        msg_id: ID —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        text: –¢–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
        kb: –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
        **kwargs: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è edit_message_text
    """
    # –ù–µ —ç–∫—Ä–∞–Ω–∏—Ä—É–µ–º HTML-—Ç–µ–≥–∏, –µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è HTML —Ä–µ–∂–∏–º
    # –≠–∫—Ä–∞–Ω–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –¥–ª—è Markdown
    parse_mode = kwargs.get("parse_mode")
    if parse_mode in ("MarkdownV2", "MARKDOWN_V2") and not (
        text and text.startswith("\\")
    ):
        text = escape_html(text)
    
    # –í—ã–∑—ã–≤–∞–µ–º –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—É—é –≤–µ—Ä—Å–∏—é —Ñ—É–Ω–∫—Ü–∏–∏
    return await optimized_safe_edit(bot, chat_id, msg_id, text, kb, **kwargs)


from app.utils.api_decorators import with_async_retry_backoff, ErrorType


@with_async_retry_backoff(max_retries=2, initial_backoff=1.0, backoff_factor=2.0)
async def handle_field_edit(message, state: FSMContext):
    """
    –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–ª–µ–π –∏–Ω–≤–æ–π—Å–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞.
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –¥–µ–∫–æ—Ä–∞—Ç–æ—Ä with_async_retry_backoff –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫.
    """
    logger.debug(f"BUGFIX: Starting field edit handler for user {message.from_user.id}")
    
    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ —Å–æ—Å—Ç–æ—è–Ω–∏—è
    data = await state.get_data()
    idx = data.get("edit_idx")
    field = data.get("edit_field")
    msg_id = data.get("msg_id")
    lang = data.get("lang", "en")  # –ü–æ–ª—É—á–∞–µ–º —è–∑—ã–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    
    # –í–ê–ñ–ù–û: –æ—á–∏—â–∞–µ–º —Ä–µ–∂–∏–º —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è, —á—Ç–æ–±—ã —Å–ª–µ–¥—É—é—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–ª–∏—Å—å –∫–∞–∫ –æ–±—ã—á–Ω—ã–µ
    await state.update_data(editing_mode=None)
    logger.debug(f"BUGFIX: Cleared editing_mode in state")
    
    if idx is None or field is None or msg_id is None:
        logger.warning(
            f"Missing required field edit data in state: idx={idx}, field={field}, msg_id={msg_id}"
        )
        await message.answer(t("error.edit_data_not_found", lang=lang))
        return
    
    user_id = message.from_user.id
    key = (user_id, msg_id)
    
    logger.debug(f"BUGFIX: Looking for invoice data with key {key}")
    if key not in user_matches:
        logger.warning(f"No matches found for user {user_id}, message {msg_id}")
        await message.answer(t("error.invoice_data_not_found", lang=lang))
        return
    
    entry = user_matches[key]
    text = message.text.strip()
    
    # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é, —á—Ç–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∑–∞–ø—Ä–æ—Å
    processing_msg = await message.answer(t("status.processing_changes", lang=lang))
    
    try:
        logger.debug(
            f"BUGFIX: Processing field edit, text: '{text[:30]}...' (truncated)"
        )
        
        # –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∞–ø—Ä—è–º—É—é –¥–∞–Ω–Ω—ã–µ –≤ –∏–Ω–≤–æ–π—Å–µ
        old_value = entry["match_results"][idx].get(field, "")
        entry["match_results"][idx][field] = text
        logger.debug(f"BUGFIX: Updated {field} from '{old_value}' to '{text}'")
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –º–∞—Ç—á–µ—Ä –∑–∞–Ω–æ–≤–æ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–Ω–æ–π —Å—Ç—Ä–æ–∫–∏, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        if field in ["name", "qty", "unit"]:
            products = data_loader.load_products("data/base_products.csv")
            entry["match_results"][idx] = matcher.match_positions(
                [entry["match_results"][idx]], products
            )[0]
            logger.debug(
                f"BUGFIX: Re-matched item, new status: {entry['match_results'][idx].get('status')}"
            )
        
        # –°–æ–∑–¥–∞–µ–º –æ—Ç—á–µ—Ç
        parsed_data = entry["parsed_data"]
        report, has_errors = build_report(parsed_data, entry["match_results"], escape_html=True)
        
        # –ò—Å–ø–æ–ª—å–∑—É–µ–º HTML –æ—Ç—á–µ—Ç –±–µ–∑ —ç–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
        formatted_report = report
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–º –æ—Ç—á–µ—Ç–æ–º
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ –æ–ø–∞—Å–Ω—ã—Ö HTML-—Ç–µ–≥–æ–≤
            from app.utils.md import clean_html
            from app.keyboards import build_edit_keyboard
            
            keyboard = build_edit_keyboard(True)
            
            if '<' in formatted_report and '>' in formatted_report:
                try:
                    # –ü—Ä–æ–±—É–µ–º —Å–Ω–∞—á–∞–ª–∞ —Å HTML-—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º 
                    result = await message.answer(
                        formatted_report,
                        reply_markup=keyboard,
                        parse_mode="HTML"
                    )
                    logger.debug("Successfully sent message with HTML formatting")
                except Exception as html_error:
                    logger.error(f"Error sending with HTML parsing: {html_error}")
                    try:
                        # –ü—Ä–æ–±—É–µ–º –±–µ–∑ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
                        result = await message.answer(
                            formatted_report,
                            reply_markup=keyboard,
                            parse_mode=None
                        )
                        logger.debug("Successfully sent message without HTML parsing")
                    except Exception as format_error:
                        logger.error(f"Error sending without HTML parsing: {format_error}")
                        # –ï—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å - –æ—á–∏—â–∞–µ–º HTML-—Ç–µ–≥–∏
                        clean_formatted_report = clean_html(formatted_report)
                        result = await message.answer(
                            clean_formatted_report,
                            reply_markup=keyboard,
                            parse_mode=None
                        )
                        logger.debug("Sent message with cleaned HTML")
            else:
                # –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π —Å–ª—É—á–∞–π - –ø—Ä–æ–±—É–µ–º —Å HTML
                result = await message.answer(
                    formatted_report,
                    reply_markup=keyboard,
                    parse_mode="HTML"
                )
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Å—ã–ª–∫–∏ –≤ user_matches —Å –Ω–æ–≤—ã–º ID —Å–æ–æ–±—â–µ–Ω–∏—è
            new_msg_id = result.message_id
            new_key = (user_id, new_msg_id)
            user_matches[new_key] = entry.copy()
            
            # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—É—é –∑–∞–ø–∏—Å—å
            if key in user_matches and key != new_key:
                del user_matches[key]
            
            logger.debug(f"BUGFIX: Created new report with message_id {new_msg_id}")
            
        except Exception as e:
            logger.error("Telegram error: %s Text length: %d Text sample: %s", 
                         str(e), len(formatted_report), formatted_report[:200])
            # –ü—ã—Ç–∞–µ–º—Å—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –±–µ–∑ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –±–µ–∑ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
            try:
                simple_msg = t("example.edit_field_success", {"field": field, "value": text, "line": idx+1}, lang=lang)
                if not simple_msg:
                    simple_msg = f"Field '{field}' updated to '{text}' for line {idx+1}"
                result = await message.answer(simple_msg, parse_mode=None)
                logger.info("Sent fallback simple message")
                return  # –í—ã—Ö–æ–¥–∏–º –¥–æ—Å—Ä–æ—á–Ω–æ
            except Exception as final_e:
                logger.error(f"Final fallback message failed: {final_e}")
                try:
                    # –ö—Ä–∞–π–Ω–∏–π —Å–ª—É—á–∞–π - –ø—Ä–æ—Å—Ç–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –±–µ–∑ i18n
                    result = await message.answer("Field updated successfully.", parse_mode=None)
                    logger.info("Sent basic fallback message")
                    return  # –í—ã—Ö–æ–¥–∏–º –¥–æ—Å—Ä–æ—á–Ω–æ
                except Exception as absolutely_final_e:
                    logger.error(f"Absolutely final fallback failed: {absolutely_final_e}")
                    raise
        
    except Exception as e:
        logger.error(f"Error handling field edit: {str(e)}")
        await message.answer(
            t("error.edit_failed", lang=lang) or "–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∏–∑–º–µ–Ω–µ–Ω–∏–π. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."
        )
    finally:
        # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –∑–∞–≥—Ä—É–∑–∫–µ
        try:
            await bot.delete_message(message.chat.id, processing_msg.message_id)
        except Exception:
            pass
        
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –≤ —Ä–µ–∂–∏–º —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏–Ω–≤–æ–π—Å–∞
        await state.set_state(NotaStates.editing)


async def cb_confirm(callback: CallbackQuery, state: FSMContext):
    # –î–µ–ª–µ–≥–∏—Ä—É–µ–º –æ–±—Ä–∞–±–æ—Ç–∫—É –≤ —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫
    from app.handlers.syrve_handler import handle_invoice_confirm
    
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–µ–∞–ª—å–Ω—É—é –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—é —Å Syrve
    await handle_invoice_confirm(callback, state)


async def help_command(message, state: FSMContext):
    # –ü–æ–ª—É—á–∞–µ–º —è–∑—ã–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    data = await state.get_data()
    lang = data.get("lang", "en")
    
    await state.set_state(NotaStates.help)
    await message.answer(
        t("main.bot_help", lang=lang),
        reply_markup=kb_help_back(),
    )


async def cancel_command(message, state: FSMContext):
    # –ü–æ–ª—É—á–∞–µ–º —è–∑—ã–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    data = await state.get_data()
    lang = data.get("lang", "en")

    await state.set_state(NotaStates.main_menu)
    await message.answer(
        t("main.ready_to_work", lang=lang),
        reply_markup=kb_main(),
    )


async def handle_edit_reply(message):
    user_id = message.from_user.id
    orig_msg_id = message.reply_to_message.message_id
    key = (user_id, orig_msg_id)
    if key not in user_matches:
        return
    entry = user_matches[key]
    if "edit_idx" not in entry:
        return
    idx = entry.pop("edit_idx")
    # Update name (simplest: replace name, keep other fields)
    match_results = entry["match_results"]
    match_results[idx]["name"] = message.text.strip()
    match_results[idx]["status"] = "unknown"  # Or re-match if needed
    parsed_data = entry["parsed_data"]
    report, has_errors = build_report(parsed_data, match_results)
    await message.reply(f"Updated line {idx+1}.\n" + report)


from app.keyboards import (
    kb_main,
    kb_upload,
    kb_help_back,
    build_main_kb,
    build_edit_keyboard,
    kb_set_supplier,
    kb_unit_buttons,
    kb_cancel_all
)
from app.assistants.client import client

async def confirm_fuzzy_name(callback: CallbackQuery, state: FSMContext):
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è fuzzy-—Å–æ–≤–ø–∞–¥–µ–Ω–∏—è –∏–º–µ–Ω–∏ –ø—Ä–æ–¥—É–∫—Ç–∞.
    
    Args:
        callback: Callback –∑–∞–ø—Ä–æ—Å –æ—Ç –∫–Ω–æ–ø–∫–∏ "–î–∞"
        state: –°–æ—Å—Ç–æ—è–Ω–∏–µ FSM –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    """
    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ state
    data = await state.get_data()
    fuzzy_match = data.get("fuzzy_match")
    fuzzy_line = data.get("fuzzy_line")
    fuzzy_msg_id = data.get("fuzzy_msg_id")
    lang = data.get("lang", "en")  # –ü–æ–ª—É—á–∞–µ–º —è–∑—ã–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    
    if not all([fuzzy_match, fuzzy_line is not None, fuzzy_msg_id]):
        await callback.message.answer(t("error.confirm_data_not_found", lang=lang))
        await state.set_state(NotaStates.editing)
        await callback.answer()
        return
    
    # –ü–æ–ª—É—á–∞–µ–º –∫–ª—é—á –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –¥–∞–Ω–Ω—ã–º –∏–Ω–≤–æ–π—Å–∞
    user_id = callback.from_user.id
    key = (user_id, fuzzy_msg_id)
    
    if key not in user_matches:
        alt_keys = [k for k in user_matches.keys() if k[0] == user_id]
        if alt_keys:
            key = max(alt_keys, key=lambda k: k[1])
        else:
            await callback.message.answer(t("error.invoice_data_not_found", lang=lang))
            await state.set_state(NotaStates.editing)
            await callback.answer()
            return
    
    entry = user_matches[key]
    
    # –û–±–Ω–æ–≤–ª—è–µ–º –∏–º—è –ø—Ä–æ–¥—É–∫—Ç–∞
    entry["match_results"][fuzzy_line]["name"] = fuzzy_match
    
    # –ó–∞–≥—Ä—É–∂–∞–µ–º –±–∞–∑—É –ø—Ä–æ–¥—É–∫—Ç–æ–≤ –¥–ª—è –ø–µ—Ä–µ–ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è
    products = data_loader.load_products("data/base_products.csv")
    
    # –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º matcher –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
    updated_positions = matcher.match_positions(
        [entry["match_results"][fuzzy_line]], 
        products
    )
    
    if updated_positions:
        entry["match_results"][fuzzy_line] = updated_positions[0]
    
    # –§–æ—Ä–º–∏—Ä—É–µ–º –Ω–æ–≤—ã–π –æ—Ç—á–µ—Ç
    report, has_errors = build_report(entry["parsed_data"], entry["match_results"], escape_html=True)
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–º –æ—Ç—á–µ—Ç–æ–º
    result = await callback.message.answer(
        report,
        reply_markup=build_main_kb(has_errors=has_errors),
        parse_mode="HTML"
    )
    
    # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Å—ã–ª–∫—É –≤ user_matches —Å –Ω–æ–≤—ã–º ID —Å–æ–æ–±—â–µ–Ω–∏—è
    new_msg_id = result.message_id
    new_key = (user_id, new_msg_id)
    user_matches[new_key] = entry.copy()
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ–≤—ã–π message_id –≤ state
    await state.update_data(edit_msg_id=new_msg_id)
    
    # –£–±–∏—Ä–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∫–Ω–æ–ø–∫–∞–º–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
    await callback.message.edit_reply_markup(reply_markup=None)
    
    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –≤ —Ä–µ–∂–∏–º –æ–±—ã—á–Ω–æ–≥–æ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
    await state.set_state(NotaStates.editing)
    
    # –û—Ç–≤–µ—á–∞–µ–º –Ω–∞ callback
    await callback.answer()


async def reject_fuzzy_name(callback: CallbackQuery, state: FSMContext):
    """
    –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏—è fuzzy-—Å–æ–≤–ø–∞–¥–µ–Ω–∏—è –∏–º–µ–Ω–∏ –ø—Ä–æ–¥—É–∫—Ç–∞.
    
    Args:
        callback: Callback –∑–∞–ø—Ä–æ—Å –æ—Ç –∫–Ω–æ–ø–∫–∏ "–ù–µ—Ç"
        state: –°–æ—Å—Ç–æ—è–Ω–∏–µ FSM –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    """
    # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ state
    data = await state.get_data()
    fuzzy_original = data.get("fuzzy_original")
    fuzzy_line = data.get("fuzzy_line")
    fuzzy_msg_id = data.get("fuzzy_msg_id")
    lang = data.get("lang", "en")  # –ü–æ–ª—É—á–∞–µ–º —è–∑—ã–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    
    if not all([fuzzy_original, fuzzy_line is not None, fuzzy_msg_id]):
        await callback.message.answer(t("error.reject_data_not_found", lang=lang))
        await state.set_state(NotaStates.editing)
        await callback.answer()
        return
    
    # –ü–æ–ª—É—á–∞–µ–º –∫–ª—é—á –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –¥–∞–Ω–Ω—ã–º –∏–Ω–≤–æ–π—Å–∞
    user_id = callback.from_user.id
    key = (user_id, fuzzy_msg_id)
    
    if key not in user_matches:
        alt_keys = [k for k in user_matches.keys() if k[0] == user_id]
        if alt_keys:
            key = max(alt_keys, key=lambda k: k[1])
        else:
            await callback.message.answer(t("error.invoice_data_not_found", lang=lang))
            await state.set_state(NotaStates.editing)
            await callback.answer()
            return
    
    entry = user_matches[key]
    
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ –≤–≤–µ–¥–µ–Ω–Ω–æ–µ –∏–º—è
    entry["match_results"][fuzzy_line]["name"] = fuzzy_original
    entry["match_results"][fuzzy_line]["status"] = "unknown"
    
    # –§–æ—Ä–º–∏—Ä—É–µ–º –Ω–æ–≤—ã–π –æ—Ç—á–µ—Ç
    report, has_errors = build_report(entry["parsed_data"], entry["match_results"], escape_html=True)
    
    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–º –æ—Ç—á–µ—Ç–æ–º
    result = await callback.message.answer(
        report,
        reply_markup=build_main_kb(has_errors=has_errors),
        parse_mode="HTML"
    )
    
    # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Å—ã–ª–∫—É –≤ user_matches —Å –Ω–æ–≤—ã–º ID —Å–æ–æ–±—â–µ–Ω–∏—è
    new_msg_id = result.message_id
    new_key = (user_id, new_msg_id)
    user_matches[new_key] = entry.copy()
    
    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ–≤—ã–π message_id –≤ state
    await state.update_data(edit_msg_id=new_msg_id)
    
    # –£–±–∏—Ä–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∫–Ω–æ–ø–∫–∞–º–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
    await callback.message.edit_reply_markup(reply_markup=None)
    
    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –≤ —Ä–µ–∂–∏–º –æ–±—ã—á–Ω–æ–≥–æ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
    await state.set_state(NotaStates.editing)
    
    # –û—Ç–≤–µ—á–∞–µ–º –Ω–∞ callback
    await callback.answer()


async def text_fallback(message):
    await message.answer(
        "üì∏ Please send an invoice photo (image only).", parse_mode=None
    )


# Silence unhandled update logs
async def _dummy(update, data):
    pass


logging.getLogger("aiogram.event").setLevel(logging.DEBUG)


# Remove duplicate NotaStates class
# In-memory store for user sessions: {user_id: {msg_id: {...}}}
user_matches = {}

# Removed duplicate safe_edit function


async def text_fallback(message):
    await message.answer(
        "üì∏ Please send an invoice photo (image only).", parse_mode=None
    )


import signal
import sys
import os

def _graceful_shutdown(signum, frame):
    logger.info(f"–ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è ({signum}), –≤—ã–ø–æ–ª–Ω—è–µ–º graceful shutdown...")
    
    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–±—â–∏–π —Ç–∞–π–º–∞—É—Ç –≤ 25 —Å–µ–∫—É–Ω–¥ –¥–ª—è –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
    # –¥–∞–∂–µ –µ—Å–ª–∏ —á—Ç–æ-—Ç–æ –∑–∞–≤–∏—Å–Ω–µ—Ç –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ shutdown
    def alarm_handler(signum, frame):
        logger.warning("–¢–∞–π–º–∞—É—Ç graceful shutdown –ø—Ä–µ–≤—ã—à–µ–Ω, –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ")
        sys.exit(1)
    
    # –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ —Å–∏–≥–Ω–∞–ª–∞ –∏ —Ç–∞–π–º–µ—Ä–∞
    old_alarm_handler = signal.signal(signal.SIGALRM, alarm_handler)
    old_alarm_time = signal.alarm(25)  # 25 —Å–µ–∫—É–Ω–¥ –Ω–∞ –≤—Å–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
    
    try:
        # 1. Stop background threads first
        logger.info("–û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–æ–Ω–æ–≤—ã–µ –ø–æ—Ç–æ–∫–∏...")
        try:
            # Stop the Redis cache cleanup thread
            from app.utils.redis_cache import _local_cache
            if hasattr(_local_cache, 'stop_cleanup'):
                _local_cache.stop_cleanup()
                logger.info("–ü–æ—Ç–æ–∫ –æ—á–∏—Å—Ç–∫–∏ –∫—ç—à–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
        except Exception as thread_err:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ —Ñ–æ–Ω–æ–≤—ã—Ö –ø–æ—Ç–æ–∫–æ–≤: {thread_err}")

        # 2. Close Redis connection if it exists
        try:
            from app.utils.redis_cache import get_redis
            redis_conn = get_redis()
            if redis_conn:
                logger.info("–ó–∞–∫—Ä—ã–≤–∞–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å Redis...")
                redis_conn.close()
                logger.info("–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å Redis –∑–∞–∫—Ä—ã—Ç–æ")
        except Exception as redis_err:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ Redis: {redis_err}")

        # 3. Cancel any pending OpenAI requests and shut down thread pool
        logger.info("–û—Ç–º–µ–Ω—è–µ–º –∑–∞–ø—Ä–æ—Å—ã OpenAI API...")
        try:
            # Shutdown thread pool first to prevent new async tasks
            from app.assistants.thread_pool import shutdown_thread_pool
            loop = asyncio.get_event_loop()
            if loop.is_running():
                shutdown_task = asyncio.run_coroutine_threadsafe(shutdown_thread_pool(), loop)
                # –£–º–µ–Ω—å—à–∞–µ–º —Ç–∞–π–º–∞—É—Ç —Å 3 –¥–æ 1.5 —Å–µ–∫
                try:
                    shutdown_task.result(timeout=1.5)
                except (asyncio.TimeoutError, concurrent.futures.TimeoutError):
                    logger.warning("Timeout waiting for thread pool shutdown")
                except Exception as pool_err:
                    logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ thread pool: {pool_err}")
            
            # Close the OpenAI client connection
            try:
                from app.config import get_chat_client
                client = get_chat_client()
                if client and hasattr(client, '_client') and hasattr(client._client, 'http_client'):
                    client._client.http_client.close()  # Close the underlying HTTP client
                    logger.info("HTTP –∫–ª–∏–µ–Ω—Ç OpenAI –∑–∞–∫—Ä—ã—Ç")
            except Exception as client_err:
                logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ HTTP –∫–ª–∏–µ–Ω—Ç–∞: {client_err}")
        except Exception as openai_err:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ –∫–ª–∏–µ–Ω—Ç–∞ OpenAI: {openai_err}")

        # 4. Stop the bot polling and dispatcher - –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω—ã–π —à–∞–≥
        if 'dp' in globals() and dp:
            logger.info("–û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –¥–∏—Å–ø–µ—Ç—á–µ—Ä –±–æ—Ç–∞...")
            if hasattr(dp, '_polling'):
                dp._polling = False
            loop = asyncio.get_event_loop()
            if loop.is_running():
                try:
                    # –£–º–µ–Ω—å—à–∞–µ–º —Ç–∞–π–º–∞—É—Ç —Å 5 –¥–æ 2 —Å–µ–∫
                    stop_task = asyncio.run_coroutine_threadsafe(dp.stop_polling(), loop)
                    stop_task.result(timeout=2.0)
                    logger.info("–û–ø—Ä–æ—Å Telegram API –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
                except (asyncio.TimeoutError, concurrent.futures.TimeoutError):
                    logger.warning("Timeout waiting for polling to stop")
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ –æ–ø—Ä–æ—Å–∞: {e}")

        # 5. Close event loop properly
        logger.info("–û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º event loop...")
        try:
            loop = asyncio.get_event_loop()
            if loop.is_running():
                # Collect and close all pending tasks
                pending = asyncio.all_tasks(loop)
                if pending:
                    logger.info(f"–û—Ç–º–µ–Ω—è–µ–º {len(pending)} –Ω–µ–∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á...")
                    for task in pending:
                        if not task.done():
                            task.cancel()
                    
                    # –£–º–µ–Ω—å—à–∞–µ–º —Ç–∞–π–º–∞—É—Ç —Å 2 –¥–æ 1 —Å–µ–∫
                    try:
                        gather_task = asyncio.run_coroutine_threadsafe(
                            asyncio.gather(*pending, return_exceptions=True), 
                            loop
                        )
                        gather_task.result(timeout=1.0)
                    except (asyncio.TimeoutError, concurrent.futures.TimeoutError):
                        logger.warning("Timeout waiting for tasks to cancel")
                    except Exception as e:
                        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–º–µ–Ω–µ –∑–∞–¥–∞—á: {e}")
                        
                # Now stop the loop
                loop.stop()
                logger.info("Event loop –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
        except Exception as loop_err:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ event loop: {loop_err}")
        
        # –ï—Å–ª–∏ loop –≤—Å—ë –µ—â—ë –∞–∫—Ç–∏–≤–µ–Ω, —Ç–æ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –µ–≥–æ
        if loop.is_running():
            logger.warning("Event loop –≤—Å—ë –µ—â—ë –∞–∫—Ç–∏–≤–µ–Ω, –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º...")
            loop.close()
            logger.info("Event loop –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏: {e}")
    finally:
        # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–∏–≥–Ω–∞–ª–∞ –∏ —Ç–∞–π–º–µ—Ä
        signal.signal(signal.SIGALRM, old_alarm_handler)
        signal.alarm(old_alarm_time)  
        
        logger.info("Graceful shutdown –∑–∞–≤–µ—Ä—à–µ–Ω")
        # –ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –ø—Ä–æ—Ü–µ—Å—Å–∞
        os._exit(0)

if __name__ == "__main__":
    signal.signal(signal.SIGTERM, _graceful_shutdown)
    signal.signal(signal.SIGINT, _graceful_shutdown)

    async def main():
        # –ü–∞—Ä—Å–∏–Ω–≥ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
        parser = argparse.ArgumentParser(description='Nota Telegram Bot')
        parser.add_argument('--test-mode', action='store_true', help='–ó–∞–ø—É—Å–∫ –≤ —Ç–µ—Å—Ç–æ–≤–æ–º —Ä–µ–∂–∏–º–µ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π')
        args = parser.parse_args()
        
        # –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è –ª–æ–≥–æ–≤ –µ—Å–ª–∏ –µ—ë –Ω–µ—Ç
        os.makedirs("logs", exist_ok=True)
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –º–æ–Ω–∏—Ç–æ—Ä –æ—à–∏–±–æ–∫
        from app.actions.error_monitor import start_error_monitor
        error_monitor = start_error_monitor("logs/bot.log")
        logger.info("AI Action –º–æ–Ω–∏—Ç–æ—Ä –æ—à–∏–±–æ–∫ –∑–∞–ø—É—â–µ–Ω")
        
        # –¢–µ—Å—Ç–æ–≤—ã–π —Ä–µ–∂–∏–º - –ø—Ä–æ—Å—Ç–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –∏ –≤—ã—Ö–æ–¥–∏–º
        if args.test_mode:
            logger.info("–ó–∞–ø—É—â–µ–Ω –≤ —Ç–µ—Å—Ç–æ–≤–æ–º —Ä–µ–∂–∏–º–µ. –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π:")
            logger.info("‚úÖ Python modules loaded successfully")
            try:
                import numpy as np
                logger.info("‚úÖ numpy imported successfully")
            except ImportError as e:
                logger.error(f"‚ùå Error importing numpy: {e}")
                return 1
            
            try:
                import cv2
                logger.info("‚úÖ OpenCV imported successfully")
            except ImportError as e:
                logger.error(f"‚ùå Error importing OpenCV: {e}")
                return 1
            
            try:
                from PIL import Image
                logger.info("‚úÖ Pillow imported successfully")
            except ImportError as e:
                logger.error(f"‚ùå Error importing Pillow: {e}")
                return 1
            
            logger.info("‚úÖ All dependencies check passed!")
            return 0
        
        # –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –∑–∞–ø—É—Å–∫ –±–æ—Ç–∞
        # –°–æ–∑–¥–∞–µ–º –±–æ—Ç–∞ –∏ –¥–∏—Å–ø–µ—Ç—á–µ—Ä
        bot, dp = create_bot_and_dispatcher()
        register_handlers(dp, bot)
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
        root_logger = logging.getLogger()
        logger.debug(f"Logger configuration: {len(root_logger.handlers)} handlers")
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞ —Å—Ä–∞–∑—É, –Ω–µ –¥–æ–∂–∏–¥–∞—è—Å—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ø—É–ª–∞
        polling_task = asyncio.create_task(dp.start_polling(bot))
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø—É–ª –ø–æ—Ç–æ–∫–æ–≤ OpenAI Assistant API –≤ —Ñ–æ–Ω–æ–≤–æ–º —Ä–µ–∂–∏–º–µ
        async def init_openai_pool():
            try:
                from app.assistants.client import client, initialize_pool
                logger.info("Initializing OpenAI thread pool in background...")
                await initialize_pool(client)
                logger.info("OpenAI thread pool initialized successfully")
            except Exception as e:
                logger.error(f"Error initializing OpenAI pool: {e}")
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é –ø—É–ª–∞ –≤ —Ñ–æ–Ω–æ–≤–æ–º —Ä–µ–∂–∏–º–µ
        pool_task = asyncio.create_task(init_openai_pool())
        
        # –í—ã–≤–æ–¥–∏–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –≤–∫–ª—é—á–µ–Ω–Ω—ã—Ö –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è—Ö
        logger.info("Performance optimizations enabled:")
        logger.info("‚úÖ Non-blocking bot startup (immediate response)")
        logger.info("‚úÖ Background OpenAI Thread pool initialization")
        logger.info("‚úÖ Asynchronous OCR processing")
        logger.info("‚úÖ Incremental UI updates for better UX")
        logger.info("‚úÖ Parallel API processing")
        logger.info("‚úÖ Fixed i18n formatting issues")
        logger.info("‚úÖ Improved logging with duplication prevention")
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –∑–∞–¥–∞—á—É –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–π –æ—á–∏—Å—Ç–∫–∏ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
        asyncio.create_task(periodic_cleanup())
        
        # –û–∂–∏–¥–∞–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–æ–ª–ª–∏–Ω–≥–∞ (–Ω–µ –¥–æ–ª–∂–Ω–æ –ø—Ä–æ–∏–∑–æ–π—Ç–∏ –¥–æ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –±–æ—Ç–∞)
        await polling_task

    asyncio.run(main())
